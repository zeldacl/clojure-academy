buildscript {
    repositories {
        maven {
            url uri('./repo')
        }
        maven { url = 'https://files.minecraftforge.net/maven' }
//        maven { url = 'https://plugins.gradle.org/m2' }
        maven { url "http://clojars.org/repo" }
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
//        classpath "com.netflix.nebula:nebula-clojure-plugin:9.4.0"
//        classpath "dev.clojurephant:clojurephant-plugin:0.5.0"
        classpath "dev.clojurephant:clojurephant-plugin:0.6.0-alpha.4.25+20200621T144024Z"
//        classpath group: 'io.github.gradle-clojure', name: 'gradle-clojure-plugin', version: '0.4.0', changing: true
    }
}
//plugins {
//    id 'scala'
//}

apply plugin: "dev.clojurephant.clojure"

apply plugin: 'net.minecraftforge.gradle'

//apply plugin: "nebula.clojure"

// Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'maven-publish'

//plugins {
//    id 'gradle-clojure.clojure' version '0.4.0'
//    // any additional plugins declared here
//}

version = '0.1.0'
group = 'cn.li.cljacademy' // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = 'cljacademy'

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.

minecraft {
    // The mappings can be changed at any time, and must be in the following format.
    // snapshot_YYYYMMDD   Snapshot are built nightly.
    // stable_#            Stables are built at the discretion of the MCP team.
    // Use non-default mappings at your own risk. they may not always work.
    // Simply re-run your setup task after changing the mappings to update your workspace.
    // http://export.mcpbot.bspk.rs/
//    mappings channel: 'snapshot', version: '20191108-1.14.3'
//    mappings channel: 'snapshot', version: '20200119-1.14.4'
    mappings channel: 'stable', version: '58-1.14.4'
//        mappings channel: 'snapshot', version: '20201118-1.15.1'
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

    // accessTransformer = file('build/resources/main/META-INF/accesstransformer.cfg')

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                'cljacademy' {
//                    workingDirectory project.file('run').canonicalPath
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                'cljacademy' {
//                    workingDirectory project.file('run').canonicalPath
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            args '--mod', 'cljacademy', '--all', '--output', file('src/generated/resources/')

            mods {
                'cljacademy' {
                    source sourceSets.main
                }
            }
        }

    }
}

idea {
    module {
        sourceDirs += project.sourceSets.main.clojure.srcDirs
        testSourceDirs += project.sourceSets.test.clojure.srcDirs
    }
}

//sourceSets {
//    main
//}
//
//sourceSets {
//    main {
//        clojure.srcDirs=[file("src/main/clojure"), file("build/clojure/main")]
//    }
//}
//sourceSets {
//    main {
//        clojure.srcDirs=[file("src/main/clojure")]
//    }
//}

//println checkClojure.sourceRoots
//println "the Project path is ${getProjectDir().absolutePath}"
//println getRootProject(). .project("clojure").getBuildDir().absolutePath
checkClojure.enabled = false
//checkClojure.dependsOn compileClojure
//clojure.warnOnReflection = true
//clojure.aotCompile = true

clojure {
    builds {
//        output-dir = "classes"
        // Defaults noted here are for custom builds, the convention plugin configures the builds it adds differently
        main {
//            sourceSet = sourceSets.main // no default
            // Configuration of the check<Build>Clojure task
            reflection = 'warn' // defaults to 'silent', can also be 'warn'
//            checkNamespaces = ['my.core', 'my.base'] // defaults to no namespaces checked
//            checkNamespaces.add('my-core') // just add a single namespace
            checkAll() // checks any namespaces found in the source set
            // Configuration of the compile<Build>Clojure task
            compiler {
//                disableLocalsClearing = true // defaults to false
//                elideMeta = ['doc', 'file'] // defaults to empty list
                directLinking = true // defaults to false
            }
//            aotNamespaces = ['my.core', 'my.base'] // defaults to no namespaces aoted
//            aotNamespaces.add('my-core') // just add a single namespace
            aotAll() // aots any namespaces found in the source set
        }
    }
}


clojureRepl {
    port = 55555 // defaults to a random open port (which will be printed in the build output)

    // handler and middleware are both optional, but don't provide both
//    handler = 'cider.nrepl/cider-nrepl-handler' // fully-qualified name of function
//    middleware = ['my.stuff/wrap-stuff'] // list of fully-qualified middleware function names (override any existing)
//    middleware 'dev/my-middleware', 'dev/my-other-middleware' // one or more full-qualified middleware function names (append to any existing)


    // clojureRepl provides fork options to customize the Java process for compilation
    forkOptions {
        memoryMaximumSize = '2048m'
        jvmArgs = ['-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005', '-Djava.awt.headless=true']
    }
}

//sourceSets {
//    dev {
//        dependencies {
//            devCompile 'nrepl:nrepl:0.6.0'
//        }
//    }
//}


repositories {
    maven {
        //仓库的路径，此处是项目根目录下的 repo 的文件夹
        url uri('./repo')
    }
    mavenCentral()
    mavenLocal()
    gradlePluginPortal()
    maven { url "http://clojars.org/repo" }
}

dependencies {
    // Specify the version of Minecraft to use, If this is any group other then 'net.minecraft' it is assumed
    // that the dep is a ForgeGradle 'patcher' dependency. And it's patches will be applied.
    // The userdev artifact is a special name and will get all sorts of transformations applied to it.
    minecraft 'net.minecraftforge:forge:1.14.4-28.2.19'
//    minecraft 'net.minecraftforge:forge:1.15.2-31.2.0'

    implementation  'org.clojure:clojure:1.10.2'

    implementation  'org.clojure:tools.logging:1.1.0'

//    testImplementation 'junit:junit:4.12'

    devImplementation 'org.clojure:tools.namespace:1.1.0'

//    devCompile 'jonase:eastwood:0.3.5'

//    devImplementation 'nrepl:nrepl:0.3.1'

    // You may put jars on which you depend on in ./libs or you may define them like so..
    // compile "some.group:artifact:version:classifier"
    // compile "some.group:artifact:version"

    // Real examples
    // compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
    // compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

    // The 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
    // provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // These dependencies get remapped to your current MCP mappings
    // deobf 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // For more info...
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html

}

// Example for how to get properties into the manifest for reading by the runtime..
jar {
    manifest {
        attributes([
                "Specification-Title": "cljacademy",
                "Specification-Vendor": "examplemodsareus",
                "Specification-Version": "1", // We are version 1 of ourselves
                "Implementation-Title": project.name,
                "Implementation-Version": "${version}",
                "Implementation-Vendor" :"examplemodsareus",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

task apiJar(type: Jar) {
    classifier = 'api'
    from sourceSets.main.output
    from sourceSets.main.allSource
    include 'cn/li/academy/api/**'
}

artifacts {
    archives apiJar
}
// Example configuration to allow publishing using the maven-publish task
// This is the preferred method to reobfuscate your jar file
jar.finalizedBy('reobfJar')
// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
//publish.dependsOn('reobfJar')

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact jar
        }
    }
    repositories {
        maven {
            url "file:///${project.projectDir}/mcmodsrepo"
        }
    }
}

//// Example configuration to allow publishing using the maven-publish task
//// we define a custom artifact that is sourced from the reobfJar output task
//// and then declare that to be published
//// Note you'll need to add a repository here
//def reobfFile = file("$buildDir/reobfJar/output.jar")
//def reobfArtifact = artifacts.add('default', reobfFile) {
//    type 'jar'
//    builtBy 'reobfJar'
//}
//publishing {
//    publications {
//        mavenJava(MavenPublication) {
//            artifact reobfArtifact
//        }
//    }
//    repositories {
//        maven {
//            url "file:///${project.projectDir}/mcmodsrepo"
//        }
//    }
//}