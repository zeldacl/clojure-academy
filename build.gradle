buildscript {
    repositories {
        maven {
            url uri('./repo')
        }
        maven { url = 'https://maven.minecraftforge.net/' }
//        maven { url = 'https://plugins.gradle.org/m2' }
        maven {
            name = 'Clojars' // name can be ommitted, but is helpful in troubleshooting
            url = 'https://repo.clojars.org/'
        }
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
//        classpath "com.netflix.nebula:nebula-clojure-plugin:9.4.0"
//        classpath "dev.clojurephant:clojurephant-plugin:0.7.0"
        classpath "dev.clojurephant:clojurephant-plugin:0.7.1-alpha.0.3+20230305T082959Z"
//        classpath group: 'io.github.gradle-clojure', name: 'gradle-clojure-plugin', version: '0.4.0', changing: true
    }
}
//plugins {
//    id 'scala'
//}
//plugins {
//    id "dev.clojurephant.clojure" version "0.7.0"
//}
apply plugin: 'net.minecraftforge.gradle'
apply plugin: "dev.clojurephant.clojure"

//apply plugin: "nebula.clojure"

// Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'maven-publish'

//plugins {
//    id 'gradle-clojure.clojure' version '0.4.0'
//    // any additional plugins declared here
//}

version = "${mc_ver}-${forge_ver}"
group = 'cn.li.cljacademy' // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = 'cljacademy'

java.toolchain.languageVersion = JavaLanguageVersion.of(8) // Mojang ships Java 8 to end users, so your mod should target Java 8.

println('Java: ' + System.getProperty('java.version') + ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ') Arch: ' + System.getProperty('os.arch'))

compileJava.options.encoding = "UTF-8"
//compileClojure.options.encoding = "UTF-8"

minecraft {
    // The mappings can be changed at any time, and must be in the following format.
    // snapshot_YYYYMMDD   Snapshot are built nightly.
    // stable_#            Stables are built at the discretion of the MCP team.
    // Use non-default mappings at your own risk. they may not always work.
    // Simply re-run your setup task after changing the mappings to update your workspace.
    // http://export.mcpbot.bspk.rs/
//    mappings channel: 'snapshot', version: '20191108-1.14.3'
//    mappings channel: 'snapshot', version: '20200119-1.14.4'
//    mappings channel: 'snapshot', version: '20200514-1.15.1'
//    mappings channel: 'stable', version: '60-1.15'
    mappings channel: 'official', version: '1.15.2'

//        mappings channel: 'snapshot', version: '20201118-1.15.1'
    // makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.

    // accessTransformer = file('build/resources/main/META-INF/accesstransformer.cfg')

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        client {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be changed as needed.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            property 'forge.logging.console.level', 'debug'

            mods {
                'cljacademy' {
//                    workingDirectory project.file('run').canonicalPath
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            // The markers can be changed as needed.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

            mods {
                'cljacademy' {
//                    workingDirectory project.file('run').canonicalPath
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'

            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'

//            args '--mod', 'cljacademy', '--all', '--output', file('src/generated/resources/')
            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            args '--mod', 'cljacademy', '--all', '--output', file('src/generated/resources/'), '--existing', file('src/main/resources/')

            mods {
                'cljacademy' {
                    source sourceSets.main
                }
            }
        }

    }
}

//idea {
//    module {
//        sourceDirs += project.sourceSets.main.clojure.srcDirs
//        testSourceDirs += project.sourceSets.test.clojure.srcDirs
//    }
//}

//sourceSets {
//    main
//}
//
//sourceSets {
//    main {
//        clojure.srcDirs=[file("src/main/clojure"), file("build/clojure/main")]
//    }
//}
//sourceSets {
//    main {
//        clojure.srcDirs=[file("src/main/clojure")]
//    }
//}

//println checkClojure.sourceRoots
//println "the Project path is ${getProjectDir().absolutePath}"
//println getRootProject(). .project("clojure").getBuildDir().absolutePath
checkClojure.enabled = false
//checkClojure.dependsOn compileClojure
//clojure.warnOnReflection = true
//clojure.aotCompile = true

//clojure {
//    builds {
////        output-dir = "classes"
//        // Defaults noted here are for custom builds, the convention plugin configures the builds it adds differently
//        main {
////            sourceSet = sourceSets.main // no default
//            // Configuration of the check<Build>Clojure task
//            reflection = 'warn' // defaults to 'silent', can also be 'warn'
////            checkNamespaces = ['my.core', 'my.base'] // defaults to no namespaces checked
////            checkNamespaces.add('my-core') // just add a single namespace
//            checkAll() // checks any namespaces found in the source set
//            // Configuration of the compile<Build>Clojure task
//            compiler {
////                disableLocalsClearing = true // defaults to false
////                elideMeta = ['doc', 'file'] // defaults to empty list
//                directLinking = true // defaults to false
//            }
////            aotNamespaces = ['my.core', 'my.base'] // defaults to no namespaces aoted
////            aotNamespaces.add('my-core') // just add a single namespace
//            aotAll() // aots any namespaces found in the source set
//        }
//    }
//}

clojure.builds {
    main {
//        checkAll()
        reflection = 'warn'
        // reset Clojure classpath to only include dependencies
//        classpath.from = sourceSets.main.compileClasspath

        // or if you also need the sources on the classpath
        // classpath.from = sourceSets.main.compileClasspath + tasks.named(sourceSets.main.processResourcesTaskName)

        // makes sure you AOT at least the namespace that produces the class(es) Java uses
        aotAll()

        compiler {
            //disableLocalsClearing = true // defaults to false
            //elideMeta = ['doc', 'file'] // defaults to empty list
            directLinking = true // defaults to false
        }
    }
}

//tasks.named('clojureRepl') {
//    classpath.from(configurations.other)
//    bind = '127.0.0.1'
//    port = 7555
//    ackPort = 8666
//    handler = 'cider/cider-nrepl-handler'
//    middleware = ['cider.nrepl/cider-middleware', 'cider.piggieback/wrap-cljs-repl']
//    forkOptions {
//        jvmArgs = ['-Xmx4g']
//    }
//}


//clojureRepl {
//    port = 55555 // defaults to a random open port (which will be printed in the build output)
//
//    // handler and middleware are both optional, but don't provide both
////    handler = 'cider.nrepl/cider-nrepl-handler' // fully-qualified name of function
////    middleware = ['my.stuff/wrap-stuff'] // list of fully-qualified middleware function names (override any existing)
////    middleware 'dev/my-middleware', 'dev/my-other-middleware' // one or more full-qualified middleware function names (append to any existing)
//
//
//    // clojureRepl provides fork options to customize the Java process for compilation
//    forkOptions {
//        memoryMaximumSize = '2048m'
//        jvmArgs = ['-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005', '-Djava.awt.headless=true']
//    }
//}

//sourceSets {
//    dev {
//        dependencies {
//            devCompile 'nrepl:nrepl:0.6.0'
//        }
//    }
//}


repositories {
    maven {
        //仓库的路径，此处是项目根目录下的 repo 的文件夹
        url uri('./repo')
    }
    mavenCentral()
    mavenLocal()
    gradlePluginPortal()
    maven {
        name = 'Clojars' // name can be ommitted, but is helpful in troubleshooting
        url = 'https://repo.clojars.org/'
    }
}

dependencies {
    // Specify the version of Minecraft to use, If this is any group other then 'net.minecraft' it is assumed
    // that the dep is a ForgeGradle 'patcher' dependency. And it's patches will be applied.
    // The userdev artifact is a special name and will get all sorts of transformations applied to it.
    minecraft 'net.minecraftforge:forge:1.15.2-31.2.57'
//    minecraft 'net.minecraftforge:forge:1.15.2-31.2.0'

    implementation  'org.clojure:clojure:1.11.1'

    implementation  'org.clojure:tools.logging:1.2.4'

//    testImplementation 'junit:junit:4.12'

    devImplementation 'org.clojure:tools.namespace:1.3.0'

//    devCompile 'jonase:eastwood:0.3.5'

//    devImplementation 'nrepl:nrepl:0.3.1'

    // You may put jars on which you depend on in ./libs or you may define them like so..
    // compile "some.group:artifact:version:classifier"
    // compile "some.group:artifact:version"

    // Real examples
    // compile 'com.mod-buildcraft:buildcraft:6.0.8:dev'  // adds buildcraft to the dev env
    // compile 'com.googlecode.efficient-java-matrix-library:ejml:0.24' // adds ejml to the dev env

    // The 'provided' configuration is for optional dependencies that exist at compile-time but might not at runtime.
    // provided 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // These dependencies get remapped to your current MCP mappings
    // deobf 'com.mod-buildcraft:buildcraft:6.0.8:dev'

    // For more info...
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html

}

// Example for how to get properties into the manifest for reading by the runtime..
jar {
    manifest {
        attributes([
                "Specification-Title": "cljacademy",
                "Specification-Vendor": "li-dev",
                "Specification-Version": "1", // We are version 1 of ourselves
                "Implementation-Title": project.name,
                "Implementation-Version": "${version}",
                "Implementation-Vendor" :"zeldacl",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

task apiJar(type: Jar) {
    classifier = 'api'
    from sourceSets.main.output
    from sourceSets.main.allSource
    include 'cn/li/academy/api/**'
}

artifacts {
    archives apiJar
}
//// Example configuration to allow publishing using the maven-publish task
//// This is the preferred method to reobfuscate your jar file
//jar.finalizedBy('reobfJar')
//// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing
////publish.dependsOn('reobfJar')
//
//publishing {
//    publications {
//        mavenJava(MavenPublication) {
//            artifact jar
//        }
//    }
//    repositories {
//        maven {
//            url "file:///${project.projectDir}/mcmodsrepo"
//        }
//    }
//}

// Example configuration to allow publishing using the maven-publish task
// we define a custom artifact that is sourced from the reobfJar output task
// and then declare that to be published
// Note you'll need to add a repository here
def reobfFile = file("$buildDir/reobfJar/output.jar")
def reobfArtifact = artifacts.add('default', reobfFile) {
    type 'jar'
    builtBy 'reobfJar'
}
publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact reobfArtifact
        }
    }
    repositories {
        maven {
            url "file:///${project.projectDir}/mcmodsrepo"
        }
    }
}
